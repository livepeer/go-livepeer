# Livepeer Networking Protocol v2 Spec

## High level flow

![broadcaster-transcoder network v2 1](https://user-images.githubusercontent.com/292510/41455677-c8437268-7032-11e8-9ce8-bfdd9b6e3fc0.png)
[Sequence diagram source](https://sequencediagram.org/index.html#initialData=C4S2BsFMAIBkQG6QA6UgJ2gOUsA7gPboDWIAdgObQIBMAUHcgIbqgDGIzZw0ASpBRABnYOgCedAELoCTACZsmIjAFoAfP0EjxALmgB5dGwAWkbU2BE+kAI51Nw0WJXrpshUuAY9hk2dEWVvxCyAxu8orK6Oq+puaW6DoAOmQAKuhMZEJsBHIY1nbhHlEAPC6x-hkJOumZ2bn5AJJkAGYEDAzgBAShRZFe0Wq1WTl5idAAygIAtpDcBVIyEZ4YZSrD9WN6UxSz88Ghc3J0QA)


## Terminology

1. **Claimable** : A job is claimable if the current block is within 256 blocks of the job's creation, or a claim has already been submitted for the job.

## Broadcaster to Registry

The broadcaster does an on-chain lookup to retrieve the orchestrator's ServiceURI in order to initiate an transcoding job.

## Broadcaster to Orchestrator:

### gRPC `GetTranscoder`

This is called by the broadcaster to request information on a transcoder from an orchestrator. The request contains the following data:

```protobuf
// This request is sent by the broadcaster in `GetTranscoder` to request
// information on which transcoder to use.
message TranscoderRequest {

  // ID of the job that the broadcaster needs a transcoder for
  int64 jobId = 1;

  // Broadcaster's signature over the jobId
  bytes sig   = 2;
}
```

The `sig` field is the broadcaster's signature using its Ethereum key, over the jobId expressed as a string. The signature consists of the resulting bytes without any further encoding.
`sig = broadcaster.Sign(jobId.String())`

Verification of `TranscoderRequest` consists of the following steps:
1. Fetch the job based on JobId.
    * TODO distinguish if an orchestrator is lagging behind and hasn't yet received the block with the job. Might require incorporating the node's **current** block number into the request.
2. Ensure the orchestrator is assigned to the job.
3. Ensure the current block falls within the valid range of `CreationBlock` ... `EndBlock` for the job.
4. Ensure the job is still claimable.
5. Verify that the signature comes from the broadcaster.

The `TranscoderInfo` response contains:

```protobuf
// The orchestrator sends this in response to `GetTranscoder`, containing the
// transcoder URI, associated credentials authorizing the broadcaster to
// use the transcoder, and miscellaneous data related to the job.
message TranscoderInfo {

  // URI of the transcoder to use for submitting segments
  string transcoder  = 1;

  // Signals the authentication method to expect within `credentials`. This
  // field is opaque to the broadcaster, and should be passed to the transcoder.
  string authType    = 2;

  // Credentials to verify the request has been authorized by an orchestrator.
  // This field is opaque to the broadcaster.
  string credentials = 3;

  // Transcoded streamId list to update the master manifest on the broadcaster.
  map<string, string> streamIds = 16;
}
```

### Notes
The authorization token will become more useful when the transcoder and orchestrator are separate entities. Additionally, the auth token can incorporate additional fields to avoid an on-chain lookup, such as the StreamID, token start time, and approximate job end time. This is stored as a base64-encoded, serialized protbuf struct.

```protobuf
// AuthToken is sent by the orchestrator and encoded in the `credentials` field
// This record is opaque to the broadcaster and is only relevant between the
// orchestrator and the transcoder.
message AuthToken {

  // Signature of the orchestrator over the remaining fields
  bytes sig   = 1;

  int64 jobId = 16;
}
```

## Broadcaster to Transcoder

### POST `/segment`

Invoked each by the broadcaster for each segment that needs to be transcoded. The transcoder address is taken from the `transcoder` field in `TranscoderInfo`.

#### Required Headers:

* **Authorization**
Taken from the `authType` field in TranscoderInfo.
* **Credentials**
Taken from the `credentials` field in TranscoderInfo.
* **Livepeer-Segment**
Proves that the broadcaster generated this segment. Serialized protobuf struct, base64 encoded.
```protobuf
message SegData {
  int64 seq  = 1;
  bytes hash = 2;
  bytes sig  = 3;
}
```
* Content-Type
`video/MP2T`

The composition of the body (and certain headers) varies based on the content-type. For the content-type of `video/MP2T` , the body is composed of the bytes of the segment.

Processing a `/segment` request consists of the following steps:

1. Verify the credentials generated by the orchestrator
2. Verify that the job hasn't expired and is still claimable.
3. Verify the segment signature from the broadcaster.
4. Download the body
5. Verify the keccak256 hash of the body matches `SegData.hash`
6. Return 200 OK header. If any of the above steps fail, a non-200 response is returned.
7. Transcoder performs additional checks and transcodes the segment.
8. Return a `TranscodeResult` body based on the results of the transcode.

#### Response:

The response is split into two parts: the 200 OK  (or error) is sent after the download, and the response body consisting of a `TranscodeResult` is sent after the transcode completes. This gives broadcasters approximate visibility into how long the upload and transcode steps each take.

```proto
// Response that a transcoder sends after transcoding a segment.
message TranscodeResult {

    // Sequence number of the transcoded results.
    int64 seq = 1;

    // Result of transcoding can be an error, or successful with more info
    oneof result {
        string error = 2;
        TranscodeData data = 3;
    }
}

// A set of transcoded segments following the profiles specified in the job.
message TranscodeData {

    // Transcoded data, in the order specified in the job options
    repeated TranscodedSegmentData segments = 1;

    // Signature of the hash of the concatenated hashes
    bytes sig = 2;
}

// Individual transcoded segment data.
message TranscodedSegmentData {

    // URL where the transcoded data can be downloaded from
    string url = 1;

}
```

### Notes

Currently, any errors are dumped directly into the response in stringified form. This gives broadcasters more information to diagnose problems with remote transcoders. However, we may not want to return such details forever, as this may leak internal information that is best left private to a transcoder.

Broadcasters can use the difference in time between the request submissing and the 200ok to approximate the upload time. The time between the 200ok and receiving the response body approximates the transcode time.

There is an end-to-end request timeout of 8 seconds, However, issues are likely to appear earlier, and any issues will likely to lead to gaps in playback and stuttering. For example, live streams that consistently take 4+ seconds (the segment length) to upload and transcode will be outrun by players.

## TLS Certificates

Self-signed, with the DNSName field is set to the host name as specified in the registry URL. Generated anew each time a transcoder node starts up.

### Notes
Orchestrator/transcoder certificates are self-signed, and generated anew each time the node starts up. The current TLS implementation in the broadcaster will fail out if the DNSName field does not match, otherwise the self-signed certificate is not verified.

IPs will also work in the DNS Name field (at least, the go client does not fail out). However, this may be problematic for orchestrators that are on unstable IPs or otherwise "move around". Arguably, orchestrators shouldn't move around, so perhaps this would serve to discourage that mode of operation.
