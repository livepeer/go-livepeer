# Livepeer Networking Protocol v2 Spec

## High level flow

![broadcaster-transcoder network v2 1](https://user-images.githubusercontent.com/292510/41455677-c8437268-7032-11e8-9ce8-bfdd9b6e3fc0.png)
[Sequence diagram source](https://sequencediagram.org/index.html#initialData=C4S2BsFMAIBkQG6QA6UgJ2gOUsA7gPboDWIAdgObQIBMAUHcgIbqgDGIzZw0ASpBRABnYOgCedAELoCTACZsmIjAFoAfP0EjxALmgB5dGwAWkbU2BE+kAI51Nw0WJXrpshUuAY9hk2dEWVvxCyAxu8orK6Oq+puaW6DoAOmQAKuhMZEJsBHIY1nbhHlEAPC6x-hkJOumZ2bn5AJJkAGYEDAzgBAShRZFe0Wq1WTl5idAAygIAtpDcBVIyEZ4YZSrD9WN6UxSz88Ghc3J0QA)

## Broadcaster to Registry

The broadcaster does an on-chain lookup to retrieve the orchestrator's ServiceURI in order to initiate an transcoding job.

## Broadcaster to Orchestrator:

### gRPC `GetTranscoder`

This is called by the broadcaster to request information on a transcoder from an orchestrator. The request contains the following data:

```protobuf
// This request is sent by the broadcaster in `GetTranscoder` to request
// information on which transcoder to use.
message TranscoderRequest {

  // ID of the job that the broadcaster needs a transcoder for
  int64 jobId = 1;

  // Broadcaster's signature over the jobId
  bytes sig   = 2;
}
```

The `sig` field is the broadcaster's signature using its Ethereum key, over the jobId expressed as a string. The signature consists of the resulting bytes without any further encoding.
`sig = broadcaster.Sign(jobId.String())`

Verification of `TranscoderRequest` consists of the following steps:
1. Fetch the job based on JobId.
    * TODO distinguish if an orchestrator is lagging behind and hasn't yet received the block with the job. Might require incorporating the node's **current** block number into the request.
2. Ensure the orchestrator is assigned to the job.
3. Ensure the current block falls within the valid range of `CreationBlock` ... `EndBlock` for the job.
4. Verify that the signature comes from the broadcaster.

The `TranscoderInfo` response contains:

```protobuf
// The orchestrator sends this in response to `GetTranscoder`, containing the
// transcoder URI, associated credentials authorizing the broadcaster to
// use the transcoder, and miscellaneous data related to the job.
message TranscoderInfo {

  // URI of the transcoder to use for submitting segments
  string transcoder  = 1;

  // Signals the authentication method to expect within `credentials`. This
  // field is opaque to the broadcaster, and should be passed to the transcoder.
  string authType    = 2;

  // Credentials to verify the request has been authorized by an orchestrator.
  // This field is opaque to the broadcaster.
  string credentials = 3;

  // Transcoded streamId list to update the master manifest on the broadcaster.
  map<string, string> streamIds = 16;
}
```

### Notes
The authorization token will become more useful when the transcoder and orchestrator are separate entities. Additionally, the auth token can incorporate additional fields to avoid an on-chain lookup, such as the StreamID, token start time, and approximate job end time. This is stored as a base64-encoded, serialized protbuf struct.

```protobuf
// AuthToken is sent by the orchestrator and encoded in the `credentials` field
// This record is opaque to the broadcaster and is only relevant between the
// orchestrator and the transcoder.
message AuthToken {

  // Signature of the orchestrator over the remaining fields
  bytes sig   = 1;

  int64 jobId = 16;
}
```

## Broadcaster to Transcoder

### POST `/segment`

Invoked each by the broadcaster for each segment that needs to be transcoded. The transcoder address is taken from the `transcoder` field in `TranscoderInfo`.

#### Required Headers:

* **Authorization**
Taken from the `authType` field in TranscoderInfo.
* **Credentials**
Taken from the `credentials` field in TranscoderInfo.
* **Livepeer-Segment**
Proves that the broadcaster generated this segment. Serialized protobuf struct, base64 encoded.
```protobuf
message SegData {
  int64 seq  = 1;
  bytes hash = 2;
  bytes sig  = 3;
}
```
* Content-Type
`video/MP2T`

The composition of the body (and certain headers) varies based on the content-type. For the content-type of `video/MP2T` , the body is composed of the bytes of the segment.

Processing a `/segment` request consists of the following steps:

1. Verify the credentials generated by the orchestrator
2. Verify that the job hasn't expired.
2. Verify the segment signature from the broadcaster.
3. Download the body
4. Verify the keccak256 hash of the body matches `SegData.hash`
5. Transcode the segment
6. Return 200 if transcoding success, non-200 otherwise.

#### Response:

200 OK after the upload has been processed. If the transcode subsequently fails, an  error message is returned. If there was an error in uploading or verifying the uploaded data, a 400- or 500- HTTP status code returned along with an error message. Otherwise, a success or error message is returned in the body.

### Notes

Currently, the stringified error is dumped directly into non-200 responses. This gives broadcasters more information to diagnose problems with remote transcoders. However, we may not want to return such details forever, as this may leak internal information that is best left private to a transcoder.

Clients can use the difference in time between the request submissing and the 200ok to approximate the upload time. The time between the 200ok and receiving the response body approximates the transcode time.

There is an end-to-end request timeout of 8 seconds. However, live streams where segments consistently take more than 4 seconds to process (the segment length) are likely to be outrun by players, leading to stuttering.

## TLS Certificates

Self-signed, with the DNSName field is set to the host name as specified in the registry URL. Generated anew each time a transcoder node starts up.

### Notes
Orchestrator/transcoder certificates are self-signed, and generated anew each time the node starts up. The current TLS implementation in the broadcaster will fail out if the DNSName field does not match, otherwise the self-signed certificate is not verified.

IPs will also work in the DNS Name field (at least, the go client does not fail out). However, this may be problematic for orchestrators that are on unstable IPs or otherwise "move around". Arguably, orchestrators shouldn't move around, so perhaps this would serve to discourage that mode of operation.
