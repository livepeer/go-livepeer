syntax = "proto3";

package net;

// RPC calls implemented by the orchestrator
service Orchestrator {

  // Called by the broadcaster to request transcoder info from an orchestrator.
  rpc GetOrchestrator(OrchestratorRequest) returns (OrchestratorInfo);
  rpc Ping(PingPong) returns (PingPong);
}

service Transcoder {

  // Called by the transcoder to register to an orchestrator. The orchestrator
  // notifies registered transcoders of segments as they come in.
  rpc RegisterTranscoder(RegisterRequest) returns (stream NotifySegment);
}

message PingPong {
  // Implementation defined
  bytes value = 1;

}


// This request is sent by the broadcaster in `GetTranscoder` to request
// information on which transcoder to use.
message OrchestratorRequest {

  // Ethereum address of the broadcaster
  bytes address = 1;

  // Broadcaster's signature over its address
  bytes sig   = 2;
}

/*
  OSInfo needed to negotiate storages that will be used.
  It carries info needed to write to the storage.
*/
message OSInfo {

  enum StorageType {
    DIRECT     = 0;
    S3         = 1;
    IPFS       = 2;
    GOOGLE     = 3;
  }

  // Storage type: direct, s3, ipfs.
  StorageType storageType = 1;

  S3OSInfo s3info = 16;
}

message S3OSInfo {

  // Host to use to connect to S3
  string host = 1;

  // Key (prefix) to use when uploading the object.
  string key = 2;

  // POST policy that S3 owner node creates to give write access to other node.
  string policy = 3;

  // Signature for POST policy.
  string signature = 4;

  // Needed for POST policy.
  string credential = 5;

  // Needed for POST policy.
  string xAmzDate = 6;
}

// The orchestrator sends this in response to `GetOrchestrator`, containing
// miscellaneous data related to the job.
message OrchestratorInfo {

  // URI of the transcoder to use for submitting segments.
  string transcoder  = 1;

  // Parameters for probabilistic micropayment tickets
  TicketParams ticket_params = 2;

  // Orchestrator returns info about own input object storage, if it wants it to be used.
  repeated OSInfo storage = 32;
}

// Data included by the broadcaster when submitting a segment for transcoding.
message SegData {

  // Manifest ID this segment belongs to
  bytes manifestId = 1;

  // Sequence number of the segment to be transcoded
  int64 seq  = 2;

  // Hash of the segment data to be transcoded
  bytes hash = 3;

  // Transcoding profiles to use
  bytes profiles = 4;

  // Broadcaster signature for the segment. Corresponds to:
  // broadcaster.sign(manifestId | seqNo | dataHash | profiles)
  bytes sig  = 5;

  // Broadcaster's preferred storage medium(s)
  // XXX should we include this in a sig somewhere until certs are authenticated?
  repeated OSInfo storage = 32;
}

// Individual transcoded segment data.
message TranscodedSegmentData {

    // URL where the transcoded data can be downloaded from.
    string url = 1;
}

// A set of transcoded segments following the profiles specified in the job.
message TranscodeData {

    // Transcoded data, in the order specified in the job options
    repeated TranscodedSegmentData segments = 1;

    // Signature of the hash of the concatenated hashes
    bytes sig = 2;
}

// Response that a transcoder sends after transcoding a segment.
message TranscodeResult {

    // Sequence number of the transcoded results.
    int64 seq = 1;

    // Result of transcoding can be an error, or successful with more info
    oneof result {
        string error = 2;
        TranscodeData data = 3;
    }
}

// Sent by the transcoder to register itself to the orchestrator.
message RegisterRequest {

    // Shared secret for auth
    string secret = 1;

    // Transcoder capacity 
    int64 capacity = 2;
}

// Sent by the orchestrator to the transcoder
message NotifySegment {

    string url      = 1;

    int64 taskId   = 16;
    bytes profiles = 17;
}

// Required parameters for probabilistic micropayment tickets
message TicketParams {
    // ETH address of the recipient
    bytes recipient = 1;

    // Pay out (in Wei) to the recipient if the ticket wins
    bytes face_value = 2;

    // Probability that the ticket wins
    bytes win_prob = 3;

    // 32 byte keccak-256 hash commitment to a random number provided
    // by the recipient
    bytes recipient_rand_hash = 4;

    // Value generated by recipient that the recipient can use
    // to derive the random number corresponding to the recipient's hash commitment
    bytes seed = 5;
}

// Probabilistic micropayment ticket
message Ticket {
    // ETH address of the recipient
    bytes recipient = 1;

    // ETH address of the sender
    bytes sender = 2;

    // Pay out (in Wei) to the recipient if the ticket wins
    bytes face_value = 3;

    // Probability that the ticket wins
    bytes win_prob = 4;

    // Monotonically increasing counter that makes the ticket
    // unique relative to a particular hash commitment to a recipient's random number
    uint32 sender_nonce = 5; 

    // 32 byte keccak-256 hash commitment to a random number provided
    // by the recipient
    bytes recipient_rand_hash = 6;
}

// Payment for transcoding video segments
message Payment {
    // Probabilistic micropayment ticket
    Ticket ticket = 1;

    // Sender signature over the ticket
    bytes sig = 2;

    // Value generated by recipient that the recipient can use
    // to derive the random number corresponding to the recipient's hash commitment
    bytes seed = 3;
}